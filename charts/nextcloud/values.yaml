## Official nextcloud image version
## ref: https://hub.docker.com/r/library/nextcloud/tags/
##
image:
  repository: nextcloud
  flavor: apache
  # default is generated by flavor and appVersion
  tag:
  pullPolicy: IfNotPresent
  # pullSecrets:
  #   - myRegistrKeySecretName

nameOverride: ""
fullnameOverride: ""
podAnnotations: {}
deploymentAnnotations: {}
deploymentLabels: {}

# Number of replicas to be deployed
replicaCount: 1

## Allowing use of ingress controllers
## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
##
ingress:
  # --
  # @section -- Ingress
  enabled: false
  # -- className
  # @section -- Ingress
  className:
  # -- Annotations
  # @section -- Ingress
  annotations: {}
  #  nginx.ingress.kubernetes.io/proxy-body-size: 4G
  #  kubernetes.io/tls-acme: "true"
  #  cert-manager.io/cluster-issuer: letsencrypt-prod
  #  # Keep this in sync with the README.md:
  #  nginx.ingress.kubernetes.io/server-snippet: |-
  #    server_tokens off;
  #    proxy_hide_header X-Powered-By;
  #    rewrite ^/.well-known/webfinger /index.php/.well-known/webfinger last;
  #    rewrite ^/.well-known/nodeinfo /index.php/.well-known/nodeinfo last;
  #    rewrite ^/.well-known/host-meta /public.php?service=host-meta last;
  #    rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json;
  #    location = /.well-known/carddav {
  #      return 301 $scheme://$host/remote.php/dav;
  #    }
  #    location = /.well-known/caldav {
  #      return 301 $scheme://$host/remote.php/dav;
  #    }
  #    location = /robots.txt {
  #      allow all;
  #      log_not_found off;
  #      access_log off;
  #    }
  #    location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ {
  #      deny all;
  #    }
  #    location ~ ^/(?:autotest|occ|issue|indie|db_|console) {
  #      deny all;
  #    }
  # -- TLS
  #   - secretName: nextcloud-tls
  #     hosts:
  #       - nextcloud.kube.home
  # @section -- Ingress
  tls:
  # --
  # @section -- Ingress
  labels: {}
  # --
  # @section -- Ingress
  path: /
  # --
  # @section -- Ingress
  pathType: Prefix


# Allow configuration of lifecycle hooks
# ref: https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/
lifecycle: {}
  # postStartCommand: []
  # preStopCommand: []

phpClientHttpsFix:
  enabled: false
  protocol: https

nextcloud:
  host: nextcloud.kube.home
  username: admin
  password: changeme
  ## Use an existing secret
  existingSecret:
    enabled: false
    # secretName: nameofsecret
    usernameKey: nextcloud-username
    passwordKey: nextcloud-password
    tokenKey: ""
    smtpUsernameKey: smtp-username
    smtpPasswordKey: smtp-password
    smtpHostKey: smtp-host
  update: 0
  # If web server is not binding default port, you can define it
  containerPort: 80
  datadir: /var/www/html/data
  persistence:
    subPath:
  # if set, we'll template this list to the NEXTCLOUD_TRUSTED_DOMAINS env var
  trustedDomains: []
  ## SMTP configuration
  mail:
    enabled: false
    # the user we send email as
    fromAddress: user
    # the domain we send email from
    domain: domain.com
    smtp:
      host: domain.com
      secure: ssl
      port: 465
      authtype: LOGIN
      name: user
      password: pass
  ## Primary ObjectStore options
  # see: https://docs.nextcloud.com/server/latest/admin_manual/configuration_files/primary_storage.html#configuring-object-storage-as-primary-storage
  objectStore:
    s3:
      # -- Enable S3
      # https://docs.nextcloud.com/server/latest/admin_manual/configuration_files/primary_storage.html#simple-storage-service-s3
      # @section -- Primary ObjectStore - S3
      enabled: false
      # -- ignored if nextcloud.objectstore.s3.existingSecret is not empty string
      # @section -- Primary ObjectStore - S3
      accessKey: ""
      # -- ignored if nextcloud.objectstore.s3.existingSecret is not empty string
      # @section -- Primary ObjectStore - S3
      secretKey: ""
      # -- use legacy auth method
      # @section -- Primary ObjectStore - S3
      legacyAuth: false
      # -- s3 endpoint to use; only required if you're not using AWS
      # @section -- Primary ObjectStore - S3
      host: ""
      # -- use TLS/SSL for S3 connections
      # @section -- Primary ObjectStore - S3
      ssl: true
      # -- default port that can be changed based on your object store, e.g. for minio, you can use 9000
      # @section -- Primary ObjectStore - S3
      port: "443"
      # -- this is the default in the nextcloud docs
      # @section -- Primary ObjectStore - S3
      region: "eu-west-1"
      # -- required if using s3, the name of the bucket you'd like to use
      # @section -- Primary ObjectStore - S3
      bucket: ""
      # -- object prefix in bucket
      # @section -- Primary ObjectStore - S3
      prefix: ""
      # -- set to true if you are not using DNS for your buckets.
      # @section -- Primary ObjectStore - S3
      usePathStyle: false
      # -- autocreate the bucket
      # @section -- Primary ObjectStore - S3
      autoCreate: false
      # -- optonal parameter: you probably want to keep this as default
      # @section -- Primary ObjectStore - S3
      storageClass: "STANDARD"
      # -- server side encryption key. learn more: https://docs.nextcloud.com/server/latest/admin_manual/configuration_files/primary_storage.html#s3-sse-c-encryption-support
      # @section -- Primary ObjectStore - S3
      sse_c_key: ""
      # -- use an existingSecret for S3 credentials. If set, we ignore the following under nextcloud.objectStore.s3
      # endpoint, accessKey, secretKey
      # @section -- Primary ObjectStore - S3
      existingSecret: ""
      secretKeys:
        # -- key in nextcloud.objectStore.s3.existingSecret to use for s3 endpoint
        # @section -- Primary ObjectStore - S3
        host: ""
        # -- key in nextcloud.objectStore.s3.existingSecret to use for s3 accessKeyID
        # @section -- Primary ObjectStore - S3
        accessKey: ""
        # -- key in nextcloud.objectStore.s3.existingSecret to use for s3 secretAccessKey
        # @section -- Primary ObjectStore - S3
        secretKey: ""
        # -- key in nextcloud.objectStore.s3.existingSecret to use for the s3 bucket
        # @section -- Primary ObjectStore - S3
        bucket: ""
        # -- key in nextcloud.objectStore.s3.existingSecret to use for the s3 sse_c_key
        # @section -- Primary ObjectStore - S3
        sse_c_key: ""
    swift:
      # -- Enabled
      # options related to using Swift as a primary object storage
      # https://docs.nextcloud.com/server/latest/admin_manual/configuration_files/primary_storage.html#openstack-swift
      # @section -- Primary ObjectStore - Swift
      enabled: false
      user:
        # -- swift user info
        # @section -- Primary ObjectStore - Swift
        domain: "Default"
        # -- swift user info
        # @section -- Primary ObjectStore - Swift
        name: ""
        # -- swift user info
        # @section -- Primary ObjectStore - Swift
        password: ""
      project:
        # -- swift project info
        # @section -- Primary ObjectStore - Swift
        name: ""
        # -- swift project info
        # @section -- Primary ObjectStore - Swift
        domain: "Default"
      # -- The Identity / Keystone endpoint
      # @section -- Primary ObjectStore - Swift
      url: ""
      # --
      # @section -- Primary ObjectStore - Swift
      region: ""
      # -- optional on some swift implementations
      # @section -- Primary ObjectStore - Swift
      service: "swift"
      # -- the container to store the data in
      # @section -- Primary ObjectStore - Swift
      container: ""
      # -- autocreate container
      # @section -- Primary ObjectStore - Swift
      autoCreate: false

  ## PHP Configuration files
  # Will be injected in /usr/local/etc/php/conf.d for apache image and in /usr/local/etc/php-fpm.d when nginx.enabled: true
  phpConfigs: {}
  ## Default config files that utilize environment variables:
  # see: https://github.com/nextcloud/docker/tree/master#auto-configuration-via-environment-variables
  # IMPORTANT: Will be used only if you put extra configs, otherwise default will come from nextcloud itself
  # Default confgurations can be found here: https://github.com/nextcloud/docker/tree/master/.config
  defaultConfigs:
    # To protect /var/www/html/config
    .htaccess: true
    # Apache configuration for rewrite urls
    apache-pretty-urls.config.php: true
    # Define APCu as local cache
    apcu.config.php: true
    # Apps directory configs
    apps.config.php: true
    # Used for auto configure database
    autoconfig.php: true
    # Redis default configuration
    redis.config.php: true
    # Reverse proxy default configuration
    reverse-proxy.config.php: true
    # S3 Object Storage as primary storage
    s3.config.php: true
    # SMTP default configuration via environment variables
    smtp.config.php: true
    # Swift Object Storage as primary storage
    swift.config.php: true
    # disables the web based updater as the default nextcloud docker image does not support it
    upgrade-disable-web.config.php: true
    # -- imaginary support config
    imaginary.config.php: false

  # Extra config files created in /var/www/html/config/
  # ref: https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/config_sample_php_parameters.html#multiple-config-php-file
  configs: {}
  # For example, to enable image and text file previews:
  #  previews.config.php: |-
  #    <?php
  #    $CONFIG = array (
  #      'enable_previews' => true,
  #      'enabledPreviewProviders' => array (
  #        'OC\Preview\Movie',
  #        'OC\Preview\PNG',
  #        'OC\Preview\JPEG',
  #        'OC\Preview\GIF',
  #        'OC\Preview\BMP',
  #        'OC\Preview\XBitmap',
  #        'OC\Preview\MP3',
  #        'OC\Preview\MP4',
  #        'OC\Preview\TXT',
  #        'OC\Preview\MarkDown',
  #        'OC\Preview\PDF'
  #      ),
  #    );

  # Hooks for auto configuration
  # Here you could write small scripts which are placed in `/docker-entrypoint-hooks.d/<hook-name>/helm.sh`
  # ref: https://github.com/nextcloud/docker?tab=readme-ov-file#auto-configuration-via-hook-folders
  hooks:
    pre-installation:
    post-installation:
    pre-upgrade:
    post-upgrade:
    before-starting:

  ## Strategy used to replace old pods
  ## IMPORTANT: use with care, it is suggested to leave as that for upgrade purposes
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  strategy:
    type: Recreate
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 1
    #   maxUnavailable: 0

  ##
  ## Extra environment variables
  extraEnv:
  #  - name: SOME_SECRET_ENV
  #    valueFrom:
  #      secretKeyRef:
  #        name: nextcloud
  #        key: secret_key

  # Extra init containers that runs before pods start.
  extraInitContainers: []
  #  - name: do-something
  #    image: busybox
  #    command: ['do', 'something']

  # Extra sidecar containers.
  extraSidecarContainers: []
  #  - name: nextcloud-logger
  #    image: busybox
  #    command: [/bin/sh, -c, 'while ! test -f "/run/nextcloud/data/nextcloud.log"; do sleep 1; done; tail -n+1 -f /run/nextcloud/data/nextcloud.log']
  #    volumeMounts:
  #    - name: nextcloud-data
  #      mountPath: /run/nextcloud/data

  # Extra mounts for the pods. Example shown is for connecting a legacy NFS volume
  # to NextCloud pods in Kubernetes. This can then be configured in External Storage
  extraVolumes:
  #  - name: nfs
  #    nfs:
  #      server: "10.0.0.1"
  #      path: "/nextcloud_data"
  #      readOnly: false
  extraVolumeMounts:
  #  - name: nfs
  #    mountPath: "/legacy_data"

  # Set securityContext parameters for the nextcloud CONTAINER only (will not affect nginx container).
  # For example, you may need to define runAsNonRoot directive
  securityContext: {}
  #   runAsUser: 33
  #   runAsGroup: 33
  #   runAsNonRoot: true
  #   readOnlyRootFilesystem: false

  # Set securityContext parameters for the entire pod. For example, you may need to define runAsNonRoot directive
  podSecurityContext: {}
  #   runAsUser: 33
  #   runAsGroup: 33
  #   runAsNonRoot: true
  #   readOnlyRootFilesystem: false

  # Settings for the MariaDB init container
  mariaDbInitContainer:
    # --
    # @section -- Database - MariaDB
    resources: {}
    # -- Set mariadb initContainer securityContext parameters. For example, you may need to define runAsNonRoot directive
    # @section -- Database - MariaDB
    securityContext: {}

  postgreSqlInitContainer:
    # --
    # @section -- Database - PostgreSQL
    resources: {}
    # -- Set postgresql initContainer securityContext parameters. For example, you may need to define runAsNonRoot directive
    # @section -- Database - PostgreSQL
    securityContext: {}


nginx:
  # -- You need to set an fpm version of the image for nextcloud if you want to use nginx!i
  # @section -- nginx
  enabled: false

  image:
    # --
    # @section -- nginx
    repository: nginx
    # --
    # @section -- nginx
    tag: alpine
    # --
    # @section -- nginx
    pullPolicy: IfNotPresent

  # --
  # @section -- nginx
  containerPort: 80
  # -- This configures nginx to listen on either IPv4, IPv6 or both
  # @section -- nginx
  ipFamilies:
    - IPv4
    # - IPv6
  config:
    # -- This generates the default nginx config as per the nextcloud documentation
    # @section -- nginx
    default: true
    # -- Header set on http requerst
    # @section -- nginx
    headers:
      # -- HSTS settings
      # WARNING: Only add the preload option once you read about
      # the consequences in https://hstspreload.org/. This option
      # will add the domain to a hardcoded list that is shipped
      # in all major browsers and getting removed from this list
      # could take several months.
      # Example:
      # "Strict-Transport-Security": "max-age=15768000; includeSubDomains; preload;"
      # @section -- nginx
      "Strict-Transport-Security": ""
      "Referrer-Policy": "no-referrer"
      "X-Content-Type-Options": "nosniff"
      "X-Download-Options": "noopen"
      "X-Frame-Options": "SAMEORIGIN"
      "X-Permitted-Cross-Domain-Policies": "none"
      "X-Robots-Tag": "noindex, nofollow"
      "X-XSS-Protection": "1; mode=block"

    # --
    #     worker_processes  1;..
    # @section -- nginx
    custom:

  # --
  # @section -- nginx
  resources: {}

  # -- Set nginx container securityContext parameters. For example, you may need to define runAsNonRoot directive
  # the nginx alpine container default user is 82
  #   runAsUser: 82
  #   runAsGroup: 33
  #   runAsNonRoot: true
  #   readOnlyRootFilesystem: true
  # @section -- nginx
  securityContext: {}

  # -- Extra environment variables
  # @section -- nginx
  extraEnv: []
  #  - name: SOME_ENV
  #    value: ENV_VALUE

internalDatabase:
  # --
  # @section -- Database - Internal
  enabled: true
  # --
  # @section -- Database - Internal
  name: nextcloud

##
## External database configuration
##
externalDatabase:
  # --
  # @section -- Database - External
  enabled: false

  # -- Supported database engines: mysql or postgresql
  # @section -- Database - External
  type: mysql

  # -- Database host. You can optionally include a colon delimited port like "myhost:1234"
  # @section -- Database - External
  host: ""

  # -- Database user
  # @section -- Database - External
  user: nextcloud

  # -- Database password
  # @section -- Database - External
  password: ""

  # -- Database name
  # @section -- Database - External
  database: nextcloud

  ## Use a existing secret
  existingSecret:
    # --
    # @section -- Database - External
    enabled: false
    # --
    # @section -- Database - External
    secretName:
    # --
    # @section -- Database - External
    usernameKey: db-username
    # --
    # @section -- Database - External
    passwordKey: db-password
    # --
    # @section -- Database - External
    hostKey: db-hostname-or-ip
    # --
    # @section -- Database - External
    databaseKey:

##
## MariaDB chart configuration
## ref: https://github.com/bitnami/charts/tree/main/bitnami/mariadb
##
mariadb:
  # --  Whether to deploy a mariadb server from the bitnami mariab db helm chart
  # to satisfy the applications database requirements. if you want to deploy this bitnami mariadb, set this and externalDatabase to true
  # To use an ALREADY DEPLOYED mariadb database, set this to false and configure the externalDatabase parameters
  # @section -- Database - MariaDB
  enabled: false

  global:
    # -- overwrites the primary.persistence.storageClass value
    # see: https://github.com/bitnami/charts/tree/main/bitnami/mariadb#global-parameters
    # @section -- Database - MariaDB
    defaultStorageClass: ""

  auth:
    # --
    # @section -- Database - MariaDB
    database: nextcloud
    # --
    # @section -- Database - MariaDB
    username: nextcloud
    # --
    # @section -- Database - MariaDB
    password: changeme
    # -- Use existing secret (auth.rootPassword, auth.password, and auth.replicationPassword will be ignored).
    # secret must contain the keys mariadb-root-password, mariadb-replication-password and mariadb-password
    # @section -- Database - MariaDB
    existingSecret: ""

  # --
  # @section -- Database - MariaDB
  architecture: standalone

  ## Enable persistence using Persistent Volume Claims
  ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  primary:
    persistence:
      # --
      # @section -- Database - MariaDB
      enabled: false
      # -- Use an existing Persistent Volume Claim (must be created ahead of time)
      # @section -- Database - MariaDB
      existingClaim: ""
      # --
      # @section -- Database - MariaDB
      storageClass: ""
      # --
      # @section -- Database - MariaDB
      accessMode: ReadWriteOnce
      # --
      # @section -- Database - MariaDB
      size: 8Gi

##
## PostgreSQL chart configuration
## for more options see https://github.com/bitnami/charts/tree/main/bitnami/postgresql
##
postgresql:
  # --
  # @section -- Database - PostgreSQL
  enabled: false
  global:
    postgresql:
      # global.postgresql.auth overrides postgresql.auth
      auth:
        # --
        # @section -- Database - PostgreSQL
        username: nextcloud
        # --
        # @section -- Database - PostgreSQL
        password: changeme
        # --
        # @section -- Database - PostgreSQL
        database: nextcloud
        # -- Name of existing secret to use for PostgreSQL credentials.
        # auth.postgresPassword, auth.password, and auth.replicationPassword will be ignored and picked up from this secret.
        # secret might also contains the key ldap-password if LDAP is enabled.
        # ldap.bind_password will be ignored and picked from this secret in this case.
        # @section -- Database - PostgreSQL
        existingSecret: ""
        secretKeys:
          # -- Names of keys in existing secret to use for PostgreSQL credentials
          # @section -- Database - PostgreSQL
          adminPasswordKey: ""
          # -- Names of keys in existing secret to use for PostgreSQL credentials
          # @section -- Database - PostgreSQL
          userPasswordKey: ""
          # -- Names of keys in existing secret to use for PostgreSQL credentials
          # @section -- Database - PostgreSQL
          replicationPasswordKey: ""
  primary:
    persistence:
      # --
      # @section -- Database - PostgreSQL
      enabled: false
      # -- Use an existing Persistent Volume Claim (must be created ahead of time)
      # @section -- Database - PostgreSQL
      existingClaim: ""
      # --
      # @section -- Database - PostgreSQL
      storageClass: ""

##
## Redis chart configuration
## for more options see https://github.com/bitnami/charts/tree/main/bitnami/redis
##
# Since Redis is used for caching only, you might want to use a storageClass with different reclaim policy and backup settings

redis:
  # --
  # @section -- redis
  enabled: false
  auth:
    # --
    # @section -- redis
    enabled: true
    # --
    # @section -- redis
    password: 'changeme'
    # -- name of an existing secret with Redis® credentials (instead of auth.password), must be created ahead of time
    # @section -- redis
    existingSecret: ""
    # -- Password key to be retrieved from existing secret
    # @section -- redis
    existingSecretPasswordKey: ""
  global:
    # --
    # @section -- redis
    storageClass: ""
  master:
    persistence:
      # --
      # @section -- redis
      enabled: true
  replica:
    persistence:
      # --
      # @section -- redis
      enabled: true

##
## Collabora chart configuration
## for more options see https://github.com/CollaboraOnline/online/tree/master/kubernetes/helm/collabora-online
##
collabora:
  # -- Activate collabora subchart
  # @section -- Collabora
  enabled: false

  autoscaling:
    # -- enable autocaling, please check collabora README.md first
    # @section -- Collabora
    enabled: false

  collabora:
    # --  HTTPS nextcloud domain, if needed
    # @section -- Collabora
    aliasgroups: []
    #   - host: "https://nextcloud.domain:443"

    # -- set extra parameters for collabora
    # you may need to add --o:ssl.termination=true
    # @section -- Collabora
    extra_params: --o:ssl.enable=false

    # -- Specify server_name when the hostname is not reachable directly for
    # example behind reverse-proxy. example: collabora.domain
    # @section -- Collabora
    server_name: null

    existingSecret:
      # -- set to true to to get collabora admin credentials from an existin secret
      # if set, ignores collabora.collabora.username and password
      # @section -- Collabora
      enabled: false
      # -- name of existing Kubernetes Secret with collboara admin credentials
      # @section -- Collabora
      secretName: ""
      # --
      # @section -- Collabora
      usernameKey: "username"
      # --
      # @section -- Collabora
      passwordKey: "password"

    # -- setup admin login credentials, these are ignored if
    # collabora.collabora.existingSecret.enabled=true
    # @section -- Collabora
    password: examplepass
    # --
    # @section -- Collabora
    username: admin

  # setup ingress
  ingress:
    # -- enable ingress for collabora online
    # @section -- Collabora
    enabled: false
    # --
    # @section -- Collabora
    className: ""
    # -- please check collabora values.yaml for nginx/haproxy annotations examples
    # @section -- Collabora
    annotations: {}
    # -- Ingress Host of collabora
    # @section -- Collabora
    hosts:
      - host: chart-example.local
        paths:
        - path: /
          pathType: ImplementationSpecific
    # -- tls for ingress
    #  - secretName: collabora-ingress-tls
    #    hosts:
    #      - collabora.domain
    # @section -- Collabora
    tls: []

  # -- see collabora helm README.md for recommended values
  # @section -- Collabora
  resources: {}


## Cronjob to execute Nextcloud background tasks
## ref: https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/background_jobs_configuration.html#cron
##
cronjob:
  enabled: false

  ## Cronjob sidecar resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}

  # Allow configuration of lifecycle hooks
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/
  lifecycle: {}
    # postStartCommand: []
    # preStopCommand: []
  # Set securityContext parameters. For example, you may need to define runAsNonRoot directive
  securityContext: {}
  #   runAsUser: 33
  #   runAsGroup: 33
  #   runAsNonRoot: true
  #   readOnlyRootFilesystem: true

service:
  type: ClusterIP
  port: 8080
  loadBalancerIP: ""
  nodePort:
  annotations: {}
    ## Insert your annotations such as below
    # test/test: pumuckel

## Enable persistence using Persistent Volume Claims
## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
##
persistence:
  # Nextcloud Data (/var/www/html)
  enabled: false
  annotations: {}
  ## nextcloud data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"

  ## A manually managed Persistent Volume and Claim
  ## Requires persistence.enabled: true
  ## If defined, PVC must be created manually before volume will be bound
  # existingClaim:

  accessMode: ReadWriteOnce
  size: 8Gi

  ## Use an additional pvc for the data directory rather than a subpath of the default PVC
  ## Useful to store data on a different storageClass (e.g. on slower disks)
  nextcloudData:
    enabled: false
    subPath:
    annotations: {}
    # storageClass: "-"
    # existingClaim:
    accessMode: ReadWriteOnce
    size: 8Gi

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

## Liveness and readiness probe values
## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
##
livenessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1
readinessProbe:
  enabled: true
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1
startupProbe:
  enabled: false
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1


## Enable pod autoscaling using HorizontalPodAutoscaler
## ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
##
hpa:
  enabled: false
  cputhreshold: 60
  minPods: 1
  maxPods: 10

nodeSelector: {}

tolerations: []

affinity: {}

dnsConfig: {}
# Custom dns config for Nextcloud containers.
# You can for example configure ndots. This may be needed in some clusters with alpine images.
# options:
#   - name: ndots
#     value: "1"

imaginary:
  # -- Start Imaginary
  # @section -- Imaginary
  enabled: false
  # -- Number of imaginary pod replicas to deploy
  # @section -- Imaginary
  replicaCount: 1

  image:
    # -- Imaginary image registry
    # @section -- Imaginary
    registry: docker.io
    # -- Imaginary image name
    # @section -- Imaginary
    repository: h2non/imaginary
    # -- Imaginary image tag
    # @section -- Imaginary
    tag: 1.2.4
    # -- Imaginary image pull policy
    # @section -- Imaginary
    pullPolicy: IfNotPresent
    # -- Imaginary image pull secrets
    # @section -- Imaginary
    pullSecrets: []

  # -- Additional annotations for imaginary
  # @section -- Imaginary
  podAnnotations: {}
  # -- Additional labels for imaginary
  # @section -- Imaginary
  podLabels: {}
  # -- Imaginary pod nodeSelector
  nodeSelector: {}
  # -- Imaginary pod tolerations
  tolerations: []

  # -- imaginary resources
  # @section -- Imaginary
  resources: {}

  # -- Optional security context for the Imaginary container
  # allowPrivilegeEscalation: false
  # capabilities:
  #   drop:
  #     - ALL
  # @section -- Imaginary
  securityContext:
    runAsUser: 1000
    runAsNonRoot: true

  # -- Optional security context for the Imaginary pod (applies to all containers in the pod)
  # runAsNonRoot: true
  # seccompProfile:
  #   type: RuntimeDefault
  # @section -- Imaginary
  podSecurityContext: {}

  readinessProbe:
    # -- active readiness probes
    # @section -- Imaginary
    enabled: true
    # -- readiness probe: threshold for failure
    # @section -- Imaginary
    failureThreshold: 3
    # -- readiness probe: threshold for success
    # @section -- Imaginary
    successThreshold: 1
    # -- readiness probe: period seconds
    # @section -- Imaginary
    periodSeconds: 10
    # -- readinees probe: timeout
    # @section -- Imaginary
    timeoutSeconds: 1
  livenessProbe:
    # -- active liveness probes
    # @section -- Imaginary
    enabled: true
    # -- liveness probe: threshold for failure
    # @section -- Imaginary
    failureThreshold: 3
    # -- liveness probe: threshold for success
    # @section -- Imaginary
    successThreshold: 1
    # -- liveness probe: period seconds
    # @section -- Imaginary
    periodSeconds: 10
    # -- liveness probe: timeout
    # @section -- Imaginary
    timeoutSeconds: 1

  service:
    # -- Imaginary: Kubernetes Service type
    # @section -- Imaginary
    type: ClusterIP
    # -- Imaginary: LoadBalancerIp for service type LoadBalancer
    # @section -- Imaginary
    loadBalancerIP:
    # -- Imaginary: NodePort for service type NodePort
    # @section -- Imaginary
    nodePort:
    # -- Additional annotations for service imaginary
    # @section -- Imaginary
    annotations: {}
    # -- Additional labels for service imaginary
    # @section -- Imaginary
    labels: {}

## Prometheus Exporter / Metrics
##
metrics:
  # -- Setup nextcloud-exporter
  # @section -- Metrics
  enabled: false

  # -- relica count of nextcloud-exporter
  # @section -- Metrics
  replicaCount: 1
  # -- Optional: becomes NEXTCLOUD_SERVER env var in the nextcloud-exporter container.
  # Without it, we will use the full name of the nextcloud service
  # @section -- Metrics
  server: ""
  # -- The metrics exporter needs to know how you serve Nextcloud either http or https
  # @section -- Metrics
  https: false
  # -- Use API token if set, otherwise fall back to password authentication
  # https://github.com/xperimental/nextcloud-exporter#token-authentication
  # Currently you still need to set the token manually in your nextcloud install
  # @section -- Metrics
  token: ""
  # -- Timeout
  # @section -- Metrics
  timeout: 5s
  # -- if set to true, exporter skips certificate verification of Nextcloud server.
  # @section -- Metrics
  tlsSkipVerify: false
  # -- Info
  # @section -- Metrics
  info:
    # Optional: becomes NEXTCLOUD_INFO_APPS env var in the nextcloud-exporter container.
    # Enables gathering of apps-related metrics. Defaults to false
    apps: false

  image:
    # -- image repository
    # @section -- Metrics
    repository: xperimental/nextcloud-exporter
    # -- image tag
    # @section -- Metrics
    tag: 0.6.2
    # -- pull policy
    # @section -- Metrics
    pullPolicy: IfNotPresent
    # -- pull secret
    # @section -- Metrics
    pullSecrets:
    #   - myRegistrKeySecretName

  # -- Metrics exporter resource requests and limits
  # ref: http://kubernetes.io/docs/user-guide/compute-resources/
  # @section -- Metrics
  resources: {}

  # -- Metrics exporter pod Annotation
  # @section -- Metrics
  podAnnotations: {}

  # -- Metrics exporter pod Labels
  # @section -- Metrics
  podLabels: {}

  # -- Metrics exporter pod nodeSelector
  # @section -- Metrics
  nodeSelector: {}

  # -- Metrics exporter pod tolerations
  # @section -- Metrics
  tolerations: []

  # -- Metrics exporter pod affinity
  # @section -- Metrics
  affinity: {}

  service:
    # -- Service Type
    # @section -- Metrics
    type: ClusterIP
    # -- Use serviceLoadBalancerIP to request a specific static IP,
    # otherwise leave blank
    # @section -- Metrics
    loadBalancerIP:
    # -- Annotations
    # @section -- Metrics
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9205"
    # -- Label on Service
    # @section -- Metrics
    labels: {}

  # -- security context for the metrics CONTAINER in the pod
  # allowPrivilegeEscalation: false
  # capabilities:
  #   drop:
  #     - ALL
  # @section -- Metrics
  securityContext:
    runAsUser: 1000
    runAsNonRoot: true

  # -- security context for the metrics POD
  # runAsNonRoot: true
  # seccompProfile:
  #   type: RuntimeDefault
  # @section -- Metrics
  podSecurityContext: {}

  ## Prometheus Operator ServiceMonitor configuration
  ##
  serviceMonitor:
    # -- Create ServiceMonitor Resource for scraping metrics using PrometheusOperator
    # @section -- Metrics
    enabled: false

    # -- Namespace in which Prometheus is running
    # @section -- Metrics
    namespace: ""

    # -- The selector of the namespace where the target service is located (defaults to the release namespace)
    # @section -- Metrics
    namespaceSelector:

    # -- The name of the label on the target service to use as the job name in prometheus.
    # @section -- Metrics
    jobLabel: ""

    # -- Interval at which metrics should be scraped
    # ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    # @section -- Metrics
    interval: 30s

    # -- Specify the timeout after which the scrape is ended
    # ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
    # @section -- Metrics
    scrapeTimeout: ""

    # -- Extra labels for the ServiceMonitor
    # @section -- Metrics
    labels: {}


rbac:
  enabled: false
  serviceaccount:
    create: true
    name: nextcloud-serviceaccount
    annotations: {}


# -- for nextcloud pod @deprecated Use `nextcloud.podSecurityContext` instead
# @section -- Deprecated
securityContext: {}
